#+TITLE: Emacs configuration file
#+AUTHOR: Nathan Aclander ( with help from The Internet and #emacs )
#+BABEL: :cache yes
#+LATEX_HEADER: \usepackage{parskip}
#+LATEX_HEADER: \usepackage{inconsolata}
#+LATEX_HEADER: \usepackage[utf8]{inputenc}
#+PROPERTY: header-args :tangle yes

* About

This is my literate emacs init file.

This, together with =init.el=, might be useful for you if:

- You come from a background of Linux, Vim, and i3
- You want your interaction with emacs to be mostly keyboard driven
- You're me

Please let me know if you find any bugs, or see any improvements that could
be made

* Configuration

This code needs to be placed initially in =init.el=

#+BEGIN_SRC emacs-lisp :tangle no
;; This file replaces itself with the actual configuration at first run.

;; We can't tangle without org!
(require 'org)
;; Open the configuration
(find-file (concat user-emacs-directory "init.org"))
;; tangle it
(org-babel-tangle)
;; load it
(load-file (concat user-emacs-directory "init.el"))
#+END_SRC

_BEGIN!_
#+BEGIN_SRC emacs-lisp
;; -*- lexical-binding: t -*-

;; For commentary, please see init.org
#+END_SRC

Create an emacs server instance if one hasn't been started.
#+BEGIN_SRC emacs-lisp
(require 'server)
(unless (server-running-p)
  (server-start))
#+END_SRC

* Package Stuff

Boring package related things, and some helper functions.

Set up the package repositories.
#+BEGIN_SRC emacs-lisp
(setq package-archives '(("elpa" . "http://tromey.com/elpa/")
                         ("melpa" . "https://melpa.org/packages/")
                         ("gnu" . "http://elpa.gnu.org/packages/")
                         ("marmalade" . "https://marmalade-repo.org/packages/")))
#+END_SRC

Load Emacs Lisp packages, and activate them.
#+BEGIN_SRC emacs-lisp
(package-initialize)
#+END_SRC

The following functions are useful to mass-redownload and recompile packages.
Usually I would use these after a major emacs change that would require me to
recompile all =elc= files.

I try to use the =/mine= suffix to denote helper functions that I've written myself.

Byte compile all emacs packages
#+BEGIN_SRC emacs-lisp
(defun byte-recompile-all/mine () (interactive)
       (progn
         (package-refresh-contents)
         (byte-recompile-directory package-user-dir nil 'force)
         ))
#+END_SRC


This Function to use to reinstall ( resync/redownload ) all installed packages.
This is "[[http://stackoverflow.com/questions/24725778/how-to-rebuild-elpa-packages-after-upgrade-of-emacs][borrowed]]" from this stack overflow thread
#+BEGIN_SRC emacs-lisp
(defun package-reinstall-activated/mine ()
  "Reinstall all activated packages."
  (interactive)
  (package-refresh-contents)
  (dolist (package-name package-activated-list)
    (when (package-installed-p package-name)
      (unless (ignore-errors                   ;some packages may fail to install
                (package-reinstall package-name)
                (warn "Package %s failed to reinstall" package-name))))))
#+END_SRC

* Miscellaneous

** Emacs Editor Look And Feel

The earlier this is done the better so we don't get random GUI elements popping
in and out when emacs loads.

Load the theme
#+BEGIN_SRC emacs-lisp
(load-theme 'sanityinc-tomorrow-eighties t)
#+END_SRC

Disable menu bars, toolbars, and welcome menus.
#+BEGIN_SRC emacs-lisp
(menu-bar-mode -1)

(setq inhibit-startup-screen t)

(tool-bar-mode -1)
#+END_SRC

Remove the scroll bar
I also added =Emacs.Scrollbars: off= in =.Xresources= or else there was
screen flickering on evil =:w= if =scroll-bar-mode= was set to =-1=
#+BEGIN_SRC emacs-lisp
(scroll-bar-mode -1)
#+END_SRC

Set the fonts. The default and line-number font should match.
#+BEGIN_SRC emacs-lisp
(setq my-font "Inconsolata")
(set-face-attribute 'line-number nil :family 'my-font)
(set-face-attribute 'default nil :family 'my-font)
#+END_SRC



Make emacs prompt =y= or =n= instead of =yes= or =no=
#+BEGIN_SRC emacs-lisp
(fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC

** Keybindings

I find that C-h C-f makes a good keybinding for find-function given that c-h f
 c-h f is bound by default to describe-function
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-h C-f") 'find-function)
#+END_SRC

Max and min buttons for GUI emacs
We need the zoom-frm package because standard text increase decrease
does not work well with [[https://github.com/alpaker/Fill-Column-Indicator][fill-column-indicator]]

#+BEGIN_SRC emacs-lisp
(if window-system (progn
    (global-set-key (kbd "C--" ) 'zoom-frm-out)
    (global-set-key (kbd "C-=") 'zoom-frm-in)
    (global-set-key (kbd "C-0") 'zoom-frm-unzoom)))
#+END_SRC

Clear the highlighting
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-l") (lambda ()
                              (interactive)
                              (evil-ex-nohighlight)
                              (evil-search-highlight-persist-remove-all)))
#+END_SRC

Make helm-mini the default quick buffer list
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-x b") 'helm-mini)
#+END_SRC

Mappings for undoing and redoing window configurations.
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-S-U" ) 'winner-undo)
(global-set-key (kbd "C-S-R") 'winner-redo)
#+END_SRC

** Scrolling

Scroll only one line at a time like in vim
#+BEGIN_SRC emacs-lisp
(setq scroll-step            1
      scroll-conservatively  10000)
#+END_SRC

Scroll one line at a time, using the mouse ( this is less "jumpy" than the defaults )
#+BEGIN_SRC emacs-lisp
(setq mouse-wheel-scroll-amount '(1 ((shift) . 1)))
#+END_SRC

** Miscellaneous Helper Functions

This auto-creates init.el from init.org, everytime I save init.org
#+BEGIN_SRC emacs-lisp
(defun tangle-init ()
  "If the current buffer is 'init.org' the code-blocks are
tangled, and the tangled file is compiled."
  (when (equal (buffer-file-name)
               (expand-file-name (concat user-emacs-directory "init.org")))
    ;; Avoid running hooks when tangling.
    (let ((prog-mode-hook nil) )
      (org-babel-tangle)
      )))
(add-hook 'after-save-hook 'tangle-init)
#+END_SRC

Reload init.el
#+BEGIN_SRC emacs-lisp
(defun reload-init/mine () (interactive) (load-file "~/.emacs.d/init.el"))
#+END_SRC

Wrapper around desktop-save / desktop-change-dir so I don't have to keep writing
down the save directory
#+BEGIN_SRC emacs-lisp
(setq desktop-save-location "~/.emacs.d/desktop-saves")
(defun desktop-save/mine () (interactive) (desktop-save desktop-save-location))
(defun desktop-load/mine () (interactive) (desktop-change-dir desktop-save-location))
#+END_SRC

** Text Configuration

Highlight the current line.
#+BEGIN_SRC emacs-lisp
(global-hl-line-mode 1)
#+END_SRC

Pretty lambdas!
#+BEGIN_SRC emacs-lisp
(add-hook 'after-change-major-mode-hook 'prettify-symbols-mode)
#+END_SRC

Enable visual-line-mode ( set wrap on ).
#+BEGIN_SRC emacs-lisp
(global-visual-line-mode t)
#+END_SRC

Use spaces instead of tabs.
#+BEGIN_SRC emacs-lisp
(setq-default indent-tabs-mode nil)
#+END_SRC

** Miscellaneous Miscellany

These are configurations which I couldn't find a place for anywhere else.

Syntax highlighting for systemd unit files.
#+BEGIN_SRC emacs-lisp
(add-to-list 'auto-mode-alist '("\\.service\\'" . conf-unix-mode))
#+END_SRC

Use IX pastebin package.
#+BEGIN_SRC emacs-lisp
(require 'ix)
#+END_SRC


Enable winner-mode, for window manipulation.
#+BEGIN_SRC emacs-lisp
(add-hook 'after-change-major-mode-hook 'winner-mode)
#+END_SRC


Set the customization file somewhere else.
#+BEGIN_SRC emacs-lisp
(setq custom-file "~/.emacs.d/custom.el")
(load custom-file)
#+END_SRC

Write backup files to their own seperate directory.
#+BEGIN_SRC emacs-lisp
    (setq backup-directory-alist
          `((".*" . ,temporary-file-directory)))
    (setq auto-save-file-name-transforms
          `((".*" ,temporary-file-directory t)))
#+END_SRC

Make backups of files, even when they're in version control.
#+BEGIN_SRC emacs-lisp
(setq vc-make-backup-files t)
#+END_SRC


Set default browser to Firefox Developer Edition
This is the actual name of the binary, which might be different on different
systems.
#+BEGIN_SRC emacs-lisp
(setq browse-url-firefox-program "firefox-developer")
(setq browse-url-browser-function 'browse-url-firefox)
#+END_SRC


Set garbage collection at 500MB instead of the default 0.76.
#+BEGIN_SRC emacs-lisp
(setq gc-cons-threshold 50000000)
#+END_SRC

Wrapper around =shell= to make it play nice with tramp
#+BEGIN_SRC emacs-lisp
(defun shell/mine () (interactive) (shell (generate-new-buffer "*shell*")))
#+END_SRC

Make emacs save a bookmark as soon as its created.
#+BEGIN_SRC emacs-lisp
(setq bookmark-save-flag 1)
#+END_SRC

Always follow symbolic-links when opening.
#+BEGIN_SRC emacs-lisp
(setq vc-follow-symlinks t)
#+END_SRC

* Package Specific Configuration

For packages that I install, I try to keep their configuration in their own
section. As I discover new packages, I append to this list frontwise.

** yafolding

A package for folding that works surprisingly well.

Set it up so its on for prog-modes
#+BEGIN_SRC emacs-lisp
(add-hook 'prog-mode-hook
          (lambda () (yafolding-mode)))
#+END_SRC

** avy

Avy lets you jump quickly to words or chars or lines. Chars is too specific, and
I use key bindings to jump to lines, so I mainly use it to jump to words.

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-M-j") 'avy-goto-word-0)
#+END_SRC

** Flyspell

Automatically start flyspell for org files

#+BEGIN_SRC emacs-lisp
(add-hook 'org-mode-hook 'turn-on-flyspell)
#+END_SRC

** imenu-list

Brings up a small menu for navigation in list buffers like org files

Focus imenu-list when activated.
#+BEGIN_SRC emacs-lisp
(setq imenu-list-focus-after-activation t)
#+END_SRC

Set its size properly
#+BEGIN_SRC emacs-lisp
(setq imenu-list-auto-resize t)
#+END_SRC

** tide

Typescript development. This setup is copied from the github readme
#+BEGIN_SRC emacs-lisp
(defun setup-tide-mode ()
  (interactive)
  (tide-setup)
  (flycheck-mode +1)
  (setq flycheck-check-syntax-automatically '(save mode-enabled))
  (eldoc-mode +1)
  (tide-hl-identifier-mode +1)
  (company-mode t))

;; aligns annotation to the right hand side
(setq company-tooltip-align-annotations t)

;; formats the buffer before saving
(add-hook 'before-save-hook 'tide-format-before-save)

(add-hook 'typescript-mode-hook #'setup-tide-mode)
#+END_SRC

** Magit

Stop Magit from asking to save unsaved buffers if being called
#+BEGIN_SRC emacs-lisp
(setq magit-save-repository-buffers nil)
#+END_SRC

** Meghanada

This package tries very hard to be intellij, and maybe one day it will achieve its dream.
#+BEGIN_SRC emacs-lisp
(require 'meghanada)
(add-hook 'java-mode-hook (lambda ()
                             (meghanada-mode t)))
#+END_SRC

I also added a hydra, in the hydra section.

** language-detection

I use this to get nice syntax highlighting for code blocks inside eww.
Unfortunatley this requires copying the following code block to my init file.
Ideally this would hidden from me. This was taken from [[https://github.com/andreasjansson/language-detection.el#eww-syntax-highlighting][here]].
#+BEGIN_SRC emacs-lisp
(require 'cl-lib)

(defun eww-tag-pre (dom)
  (let ((shr-folding-mode 'none)
        (shr-current-font 'default))
    (shr-ensure-newline)
    (insert (eww-fontify-pre dom))
    (shr-ensure-newline)))

(defun eww-fontify-pre (dom)
  (with-temp-buffer
    (shr-generic dom)
    (let ((mode (eww-buffer-auto-detect-mode)))
      (when mode
        (eww-fontify-buffer mode)))
    (buffer-string)))

(defun eww-fontify-buffer (mode)
  (delay-mode-hooks (funcall mode))
  (font-lock-default-function mode)
  (font-lock-default-fontify-region (point-min)
                                    (point-max)
                                    nil))

(defun eww-buffer-auto-detect-mode ()
  (let* ((map '((ada ada-mode)
                (awk awk-mode)
                (c c-mode)
                (cpp c++-mode)
                (clojure clojure-mode lisp-mode)
                (csharp csharp-mode java-mode)
                (css css-mode)
                (dart dart-mode)
                (delphi delphi-mode)
                (emacslisp emacs-lisp-mode)
                (erlang erlang-mode)
                (fortran fortran-mode)
                (fsharp fsharp-mode)
                (go go-mode)
                (groovy groovy-mode)
                (haskell haskell-mode)
                (html html-mode)
                (java java-mode)
                (javascript javascript-mode)
                (json json-mode javascript-mode)
                (latex latex-mode)
                (lisp lisp-mode)
                (lua lua-mode)
                (matlab matlab-mode octave-mode)
                (objc objc-mode c-mode)
                (perl perl-mode)
                (php php-mode)
                (prolog prolog-mode)
                (python python-mode)
                (r r-mode)
                (ruby ruby-mode)
                (rust rust-mode)
                (scala scala-mode)
                (shell shell-script-mode)
                (smalltalk smalltalk-mode)
                (sql sql-mode)
                (swift swift-mode)
                (visualbasic visual-basic-mode)
                (xml sgml-mode)))
         (language (language-detection-string
                    (buffer-substring-no-properties (point-min) (point-max))))
         (modes (cdr (assoc language map)))
         (mode (cl-loop for mode in modes
                        when (fboundp mode)
                        return mode)))
    (message (format "%s" language))
    (when (fboundp mode)
      mode)))

(setq shr-external-rendering-functions
      '((pre . eww-tag-pre)))
#+END_SRC

** helm-google

Helm interface to quick Google searches

This flips the default order of =helm-googl-actions= so that we use the eww
browser only for =helm-google= searches.
#+BEGIN_SRC emacs-lisp
(setq helm-google-actions
  '(("Browse URL with EWW" lambda
      (candidate)
      (eww-browse-url
      (helm-google-display-to-real candidate)))
    ("Browse URL" . browse-url)))
#+END_SRC

** webpaste

Set webpaste to ix.io, and instead of sending paste to killring send it to the
clipboard.
#+BEGIN_SRC emacs-lisp
(setq webpaste-provider-priority '("ix.io"))
(setq webpaste-add-to-killring nil)
(setq webpaste-copy-to-clipboard t)
#+END_SRC

** lisp

Configuration for various lisps

Enable using paredit in lisps
#+BEGIN_SRC emacs-lisp
(autoload 'enable-paredit-mode "paredit")
(add-hook 'emacs-lisp-mode-hook 'paredit-mode)
(add-hook 'eval-expression-minibuffer-setup-hook 'paredit-mode)
(add-hook 'ielm-mode-hook             'paredit-mode)
(add-hook 'lisp-mode-hook             'paredit-mode)
(add-hook 'lisp-interaction-mode-hook 'paredit-mode)
(add-hook 'scheme-mode-hook           'paredit-mode)
(add-hook 'cider-repl-mode-hook 'paredit-mode)
(add-hook 'clojure-mode-hook 'paredit-mode)
#+END_SRC

** Info

Some configuration for Info buffers

Use info-buffer to open info pages as seperate buffers. By default emacs keeps
reusing the same one.
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-h i") 'info-buffer)
#+END_SRC

** Uniquify

We can use Uniquify library to name them thing/init.el and other-thing/init.el,
which is much easier to make sense of.
#+BEGIN_SRC emacs-lisp
(require 'uniquify)
(setq uniquify-buffer-name-style 'forward)
#+END_SRC

** Paren

Highlight parentheses.
#+BEGIN_SRC emacs-lisp
(require 'paren)
(show-paren-mode t)
(setq show-paren-delay 0)
(setq show-paren-when-point-inside-paren t)
#+END_SRC

** Neotree

Set all-the-icons for neotree.
+BEGIN_SRC emacs-lisp
(setq neo-theme (if (display-graphic-p) 'icons 'arrow))
#+END_SRC

Make the neotree window not force a fixed size
#+BEGIN_SRC emacs-lisp
(setq neo-window-fixed-size nil)
#+END_SRC

Every time when the neotree window is opened, let it find current file and
jump to node.
#+BEGIN_SRC emacs-lisp
(setq neo-smart-open t)
#+END_SRC

Similar to find-file-in-project, NeoTree can be opened (toggled) at projectile
project root as follows ( taken from [[https://www.emacswiki.org/emacs/NeoTree][emacswiki]] ):
#+BEGIN_SRC emacs-lisp
(defun neotree-project-dir ()
    "Open NeoTree using the git root."
    (interactive)
    (let ((project-dir (projectile-project-root))
          (file-name (buffer-file-name)))
      (neotree-toggle)
      (if project-dir
          (if (neo-global--window-exists-p)
              (progn
                (neotree-dir project-dir)
                (neotree-find file-name)))
        (message "Could not find git project root."))))
#+END_SRC

** lsp-mode

Set up lsp for Java and Python. More information about lsp can be found [[https://github.com/Microsoft/language-server-protocol][here]].
The Language Server Protocol is still in its early days and support for emacs is
sparse.
#+BEGIN_SRC emacs-lisp
;(require 'lsp-java)
;(require 'lsp-python)
;(require 'lsp-mode)
;(global-lsp-mode t)

;(with-eval-after-load 'lsp-mode
;    (require 'lsp-flycheck))
#+END_SRC

** Fortune Cookie

Enable a random string from the fortune program in the scratch buffer whenver
restarting emacs. Project page is [[https://github.com/andschwa/fortune-cookie][here]].
#+BEGIN_SRC emacs-lisp
(fortune-cookie-mode t)

(setq inhibit-startup-message t)
#+END_SRC

** shell/multi-term/term/ansi-term

Configuration for [[https://www.emacswiki.org/emacs/MultiTerm][multi-term]]
#+BEGIN_SRC emacs-lisp
(require 'multi-term)

(setq multi-term-program "/bin/zsh")
#+END_SRC

Get emacs terminal ( =term= ) to play nicely with unicode characters
#+BEGIN_SRC emacs-lisp
(add-hook 'term-exec-hook
          (function
           (lambda ()
             (set-buffer-process-coding-system 'utf-8-unix 'utf-8-unix))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun my-term-hook ()
  (goto-address-mode))
(add-hook 'term-mode-hook 'my-term-hook)
#+END_SRC

Turn off helm-completion-at-point for helm mode so that zsh bash completion
works.
#+BEGIN_SRC emacs-lisp
(eval-after-load "shell"
  '(define-key shell-mode-map (kbd "TAB") #'company-complete))
(add-hook 'shell-mode-hook #'company-mode)
#+END_SRC

Rebind =C-c C-l= to clear the screen in shell-mode
#+BEGIN_SRC emacs-lisp
(require 'shell)
(define-key shell-mode-map (kbd "C-c C-l") 'comint-clear-buffer)
#+END_SRC

** Projectile

Enable [[https://github.com/bbatsov/projectile][projectile]]
#+BEGIN_SRC emacs-lisp
(require 'projectile)
(setq projectile-enable-caching t)
#+END_SRC

** Undo-Tree

Set an undo directory.
#+BEGIN_SRC emacs-lisp
(setq undo-tree-history-directory-alist '(("." . "~/.emacs.d/undo")))
#+END_SRC

Enable permanent undos.
#+BEGIN_SRC emacs-lisp
(setq undo-tree-auto-save-history t)
#+END_SRC

** iBuffer

Change list-buffers to ibuffer.
#+BEGIN_SRC emacs-lisp
(defalias 'list-buffers 'ibuffer)
#+END_SRC

** Tramp

#+BEGIN_SRC emacs-lisp
(require 'tramp)
#+END_SRC

[[https://wiki.archlinux.org/index.php/emacs#When_network_is_limited][This]] recommendation is from the Arch-Linux wiki regarding slow networking in tramp
#+BEGIN_SRC emacs-lisp
(setq tramp-ssh-controlmaster-options
      "-o ControlMaster=auto -o ControlPath='tramp.%%C' -o ControlPersist=no")
#+END_SRC

=sshx= seems to work more reliably, but I don't know why.
#+BEGIN_SRC emacs-lisp
(tramp-set-completion-function "sshx"
                               '((tramp-parse-sconfig "/etc/ssh_config")
                                 (tramp-parse-sconfig "~/.ssh/config")))
(setq tramp-default-method "sshx")
#+END_SRC

The timeout is the number of seconds since the last remote command for rereading
remote  directory contents. 0 re-reads immediately during file name completion,
nil uses cached directory contents.
#+BEGIN_SRC emacs-lisp
(setq tramp-completion-reread-directory-timeout nil)
#+END_SRC

** auto-highlight-symbol

As described [[https://www.hiroom2.com/2016/10/31/emacs-auto-highlight-symbol-package/][here]]:
#+BEGIN_SRC emacs-lisp
(add-hook 'after-init-hook 'global-auto-highlight-symbol-mode)
#+END_SRC

** Line numbers

Add line numbers. Recently emacs added built-in line numbers. So nlinum
or linum mode are no longer necessary.
#+BEGIN_SRC emacs-lisp
;(setq-default display-line-numbers 'relative)
(setq display-line-numbers-type 'relative)
;(global-display-line-numbers-mode t)
#+END_SRC

Set the background of the line numbers face to make it separate from the
rest of the buffer.
#+BEGIN_SRC emacs-lisp
(set-face-background 'line-number "grey12")
(set-face-foreground 'line-number-current-line "gold3")
#+END_SRC

Enable emacs built in line numbers, except for blacklisted major modes.
#+BEGIN_SRC emacs-lisp
(setq mine/disable-line-number-for-modes '('neotree-mode))
(add-hook 'after-change-major-mode-hook
          (lambda () (unless
                    (member major-mode mine/disable-line-number-for-modes)
                  (display-line-numbers-mode t))))
#+END_SRC

** org-wikish

 Unfortunatley this package is not in melpa yet.
#[[~/.emacs.d/org-wikish/+begin_src.org][+BEGIN_SRC]] emacs-lisp
(add-to-list 'load-path "~/.emacs.d/misc/org-wikish/")
(load "org-wikish")
#+END_SRC

Set the org-wikish directory

#+BEGIN_SRC emacs-lisp
(setq org-wikish-wiki-directory "~/.emacs.d/org-wikish/")
#+END_SRC

There is also an evil org-wikish keybinding in the Evil section.

** org-mode

#+BEGIN_SRC emacs-lisp
(require 'org)
#+END_SRC

Follow links and open non existing files.
#+BEGIN_SRC emacs-lisp
(setq org-return-follows-link t)
(setq org-open-non-existing-files t)
#+END_SRC

Open org links in the same window.
#+BEGIN_SRC emacs-lisp
(setq org-link-frame-setup '((file . find-file)))
#+END_SRC

Start all org files unfolded by default.
#+BEGIN_SRC emacs-lisp
(setq org-startup-folded nil)
#+END_SRC

Enable syntax highlighting of source code in org mode.
#+BEGIN_SRC emacs-lisp
(setq org-src-fontify-natively t)
#+END_SRC

Enable org-bullet mode
#+BEGIN_SRC emacs-lisp
(require 'org-bullets)
(add-hook 'org-mode-hook (lambda () (org-bullets-mode 1)))
#+END_SRC

Pretty fontification of source code blocks, taken from [[http://orgmode.org/worg/org-contrib/babel/examples/fontify-src-code-blocks.html][here]].
#+BEGIN_SRC emacs-lisp
(setq org-src-fontify-natively t)
#+END_SRC

Define a function to insert a heading with a timestamp
#+BEGIN_SRC emacs-lisp
(defun org-insert-heading-with-timestamp ()
  (interactive)
  (org-insert-heading-respect-content)
  (org-time-stamp-inactive))
#+END_SRC

Set up some org specific keybindings
#+BEGIN_SRC emacs-lisp
(define-key org-mode-map (kbd "<C-return>") 'org-insert-heading)
(define-key org-mode-map (kbd "<C-S-return>") 'org-insert-heading-with-timestamp)
#+END_SRC

This adds a custom org template expansion for emacs lisp. I followed the
instructions specified [[http://nicholasvanhorn.com/posts/org-structure-completion.html][here]]
#+BEGIN_SRC emacs-lisp
(add-to-list 'org-structure-template-alist '("e" "#+BEGIN_SRC emacs-lisp \n?\n#+END_SRC" ))
#+END_SRC

Set background to be darker on code blocks so that its easier to read:
#+BEGIN_SRC emacs-lisp
(set-face-background 'org-block "grey12")
#+END_SRC

Set up syntax highlighting when exporting org to Latex, then to PDF. Solution found [[https://emacs.stackexchange.com/questions/27982/export-code-blocks-in-org-mode-with-minted-environment][here]].
#+BEGIN_SRC emacs-lisp
(setq org-latex-listings 'minted
      org-latex-packages-alist '(("" "minted"))
      org-latex-pdf-process
      '("pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
        "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"))
#+END_SRC

** Python

Enable elpy
#+BEGIN_SRC emacs-lisp
(elpy-enable)
#+END_SRC

Set ipython as the shell interpreter ( such as when pressing =C-c C-c= ).
#+BEGIN_SRC emacs-lisp
(setq python-shell-interpreter "ipython"
    python-shell-interpreter-args "--simple-prompt")
#+END_SRC

** Rainbow-mode

Enable rainbow-mode, this highlights colors in buffer over the word.
#+BEGIN_SRC emacs-lisp
(require 'rainbow-mode)
#+END_SRC

Originally I used the 'after-change-major-mode-hook and it broke colors in
Helm and in magit; not sure why, but it works now.
#+BEGIN_SRC emacs-lisp
(add-hook 'prog-mode-hook 'rainbow-mode)
#+END_SRC

** Eyebrowse

[[https://github.com/wasamasa/eyebrowse][Eyebrowse]] is useful for window configuration, like in a tiling window manager.
I would have preferred to use [[https://github.com/nex3/perspective-el][perspective-el]],
but that project currently [[https://github.com/nex3/perspective-el/issues/64][does not work]] with emacs' master branch.
I would like to switch back to perspective-el when that issue is fixed.
#+BEGIN_SRC emacs-lisp
(eyebrowse-mode)
#+END_SRC

I also have a hydra configuration in the Hydra section.

** Shackle

[[https://github.com/wasamasa/shackle][Shakle]] helps keep windows at certain ratios

Align =helm= and =help= windows at the bottom with a ratio of 40%.
#+BEGIN_SRC emacs-lisp
(shackle-mode t)
(setq helm-display-function 'pop-to-buffer) ; make helm play nice
(setq shackle-rules '(("\\`\\*helm.*?\\*\\'" :regexp t :align t :size 0.5)
                      ("\\`\\*help.*?\\*\\'" :regexp t :align t :size 0.5)))
#+END_SRC

** Rainbow Delimiters

Enable rainbow parentheses
#+BEGIN_SRC emacs-lisp
(add-hook 'prog-mode-hook 'rainbow-delimiters-mode)
#+END_SRC

Custom face for rainbow parentheses taken from [[https://ericscrivner.me/2015/06/better-emacs-rainbow-delimiters-color-scheme/][here]].
#+BEGIN_SRC emacs-lisp
(custom-set-faces
 '(rainbow-delimiters-depth-1-face ((t (:foreground "dark orange"))))
 '(rainbow-delimiters-depth-2-face ((t (:foreground "deep pink"))))
 '(rainbow-delimiters-depth-3-face ((t (:foreground "chartreuse"))))
 '(rainbow-delimiters-depth-4-face ((t (:foreground "deep sky blue"))))
 '(rainbow-delimiters-depth-5-face ((t (:foreground "yellow"))))
 '(rainbow-delimiters-depth-6-face ((t (:foreground "orchid"))))
 '(rainbow-delimiters-depth-7-face ((t (:foreground "spring green"))))
 '(rainbow-delimiters-depth-8-face ((t (:foreground "sienna1")))))
#+END_SRC

** simpleclip

Enable copy, cut, and paste, to clipboard
#+BEGIN_SRC emacs-lisp
(require 'simpleclip)

(simpleclip-mode 1)
#+END_SRC

These keybindings are what's also used in most terminal emulators on Linux.
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-S-C" ) 'simpleclip-copy)
(global-set-key (kbd "C-S-X" ) 'simpleclip-cut)
(global-set-key (kbd "C-S-V" ) 'simpleclip-paste)
#+END_SRC

** Column Enforce

+I used to use =fci-mode= but that ended up causing too many problems.+
+I use a simpler package that just highlights anything past a desired line.+
+I would still like to use soemthing equivalent to =fci-mode=, eventually.+

fci-mode seems to be working again using some patches on GitHub.
Specifically, I applied the zoom patch and the patch to make fci work with
the new line-numbers built into emacs. I had to make those patches compatible
but now fci mostly works.

#+BEGIN_SRC emacs-lisp
(require 'fill-column-indicator)
(setq fci-rule-width 1)
(setq fci-rule-color "grey")
(setq fci-rule-column 80)
(add-hook 'prog-mode-hook 'fci-mode)
(add-hook 'text-mode-hook 'fci-mode)
#+END_SRC

fill-column-indicator is a little finicky when it comes to company-mode popups
or flyspell-popups but this hack below mostly works. Taken from [[https://github.com/alpaker/Fill-Column-Indicator/issues/54][here]].

#+BEGIN_SRC emacs-lisp
(defun on-off-fci-before-company(command)
  (when (string= "show" command)
    (turn-off-fci-mode))
  (when (string= "hide" command)
    (turn-on-fci-mode)))

(advice-add 'company-call-frontends :before #'on-off-fci-before-company)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(require 'column-enforce-mode)
(setq column-enforce-column 100)
(set-face-foreground 'column-enforce-face "red")
(add-hook 'prog-mode-hook 'column-enforce-mode)
(add-hook 'text-mode-hook 'column-enforce-mode)
#+END_SRC

** Git-Gutter

For now, disable git-gutter until [[https://github.com/syohex/emacs-git-gutter/issues/143][this issue]] is resolved.
#+BEGIN_SRC emacs-lisp
;(global-git-gutter-mode t)
#+END_SRC

Add this to use git-gutter and linum-mode
#+BEGIN_SRC emacs-lisp
(git-gutter:linum-setup)
#+END_SRC

Set the update interval
#+BEGIN_SRC emacs-lisp
(setq git-gutter:update-interval 2)
#+END_SRC

Customize the symbols and colors
#+BEGIN_SRC emacs-lisp
(setq git-gutter:modified-sign "â‰ˆ")

 (add-hook 'after-init-hook (lambda ()
                             (set-face-foreground 'git-gutter:modified "gold")))
#+END_SRC

** Evil

Use [https://github.com/naclander/evil-search-highlight-persist][evil-search-highlight-persist]
to keep the highlighting persistent. This is available by default using
evil-search but I prefer isearch.
#+BEGIN_SRC emacs-lisp
;(setq evil-search-module 'evil-search)
(require 'highlight)
(require 'evil-search-highlight-persist)
(global-evil-search-highlight-persist t)
#+END_SRC

Set highlighting across all windows in evil-search-highlight-persist.
#+BEGIN_SRC emacs-lisp
(setq evil-search-highlight-persist-all-windows t)
#+END_SRC

Change the default face of evil-search-highlight-persist to something better.
#+BEGIN_SRC emacs-lisp
(set-face-background 'evil-search-highlight-persist-highlight-face "gold")
(set-face-foreground 'evil-search-highlight-persist-highlight-face "black")
#+END_SRC



Change the evil-search face colors. This has to come after requiring evil so
that the face is already created. I'm currently not using evil-search so this
isn't used.
#+BEGIN_SRC emacs-lisp
(require 'evil)
(require 'evil-magit)
(set-face-background 'evil-ex-lazy-highlight "gold")
(set-face-foreground 'evil-ex-lazy-highlight "black")
#+END_SRC


Make =C-j= and =C-k= move down and up 10 lines at a time.
#+BEGIN_SRC emacs-lisp
(evil-global-set-key 'motion (kbd "C-j")
                     (lambda ()
                       (interactive
                        (evil-next-line 10))))
(evil-global-set-key 'motion (kbd "C-k")
                     (lambda ()
                       (interactive
                        (evil-previous-line 10))))
#+END_SRC

Go back to previous buffer.
#+BEGIN_SRC emacs-lisp
(evil-global-set-key 'motion (kbd "C-b") 'evil-switch-to-windows-last-buffer)
#+END_SRC

Map =;= to bring up the evil command buffer. Dired needs a special case.
#+BEGIN_SRC emacs-lisp
;(evil-global-set-key 'motion ";" 'evil-ex)
(evil-define-key 'normal dired-mode-map ";" 'evil-ex)
(evil-define-key 'normal (current-global-map) ";" 'evil-ex)
#+END_SRC

Enable evil mode in all buffers.
#+BEGIN_SRC emacs-lisp
(setq evil-motion-state-modes (append evil-emacs-state-modes
                               evil-motion-state-modes))
(setq evil-emacs-state-modes nil)
#+END_SRC

Treat =_= and =-= as a word character.
#+BEGIN_SRC emacs-lisp
(modify-syntax-entry ?_ "w")
(modify-syntax-entry ?- "w")
#+END_SRC

Some org-wikish keybindings. This makes it so that you can press enter to create
and follow links, just like in [[https://github.com/vimwiki/vimwiki][vimwiki]].
#+BEGIN_SRC emacs-lisp
(evil-mode 1)
(defun evil-org-follow-link/mine ()
  " If there is a link at point, follow it. Otherwise create an org-wikish link"
  (interactive)
  (save-excursion
    ;; If its a link, open it. Otherwise, create an org-wikish link
    (if (org-in-regexp org-bracket-link-regexp 1)
        (org-open-at-point)
      ;; Create a new page whether we're on a word, or have a region selected
      (if (use-region-p)
          (org-wikish-link-region
           (buffer-substring-no-properties (region-beginning) (region-end)))
        (org-wikish-link-word-at-point)))))
(evil-define-key 'normal org-mode-map (kbd "RET") 'evil-org-follow-link/mine)
#+END_SRC

Use flyspell-popup instead of the evil dictionary suggestion. I used to use
helm-flyspell but I think flyspell-popup is nicer
#+BEGIN_SRC emacs-lisp
;(defun mine/helm-flyspell-correct ()
;  (interactive)
;  (save-excursion (helm-flyspell-correct)))
;(evil-global-set-key 'normal (kbd "z =") 'mine/helm-flyspell-correct)
(evil-global-set-key 'normal (kbd "z =") 'flyspell-popup-correct)
#+END_SRC

Make emacs' undo more fine-grain. This is speicifc to evil. Answer found [[http://stackoverflow.com/questions/10474555/how-to-change-granularity-level-of-undo-in-emacs-evil-mode-with-undo-tree][here]].
#+BEGIN_SRC emacs-lisp
(setq evil-want-fine-undo t)
#+END_SRC

Make =C-S-d= scroll up, since =C-u= can't be used to scroll up in emacs.
#+BEGIN_SRC emacs-lisp
(evil-global-set-key 'motion (kbd "C-S-d") 'evil-scroll-up)
#+END_SRC

** Dired

#+BEGIN_SRC emacs-lisp
(require 'dired )
#+END_SRC

Auto update dired buffer if directory contents change. Found at:
http://pragmaticemacs.com/emacs/automatically-revert-buffers/
#+BEGIN_SRC emacs-lisp
(add-hook 'dired-mode-hook 'auto-revert-mode)
#+END_SRC

Human readable units in dired-mode.
#+BEGIN_SRC emacs-lisp
(setq-default dired-listing-switches "-alh")
#+END_SRC

Using the dired-subtree package, Use 'i' to open and close directories in dired
and 'I' to cycle all directories.
#+BEGIN_SRC emacs-lisp
(define-key dired-mode-map (kbd "i") 'dired-subtree-toggle)
(define-key dired-mode-map (kbd "I") 'dired-subtree-cycle)
#+END_SRC

Use [[https://github.com/domtronn/all-the-icons.el][all-the-icons]] icons in dired to make it look pretty.
#+BEGIN_SRC emacs-lisp
(add-hook 'dired-mode-hook 'all-the-icons-dired-mode)
#+END_SRC

** Highlight sexp

Enable the [[https://www.emacswiki.org/emacs/HighlightSexp][highlight sexp]] package
#+BEGIN_SRC emacs-lisp
(require 'highlight-sexp)
(add-hook 'lisp-mode-hook 'highlight-sexp-mode)
(add-hook 'clojure-mode-hook 'highlight-sexp-mode)
(add-hook 'emacs-lisp-mode-hook 'highlight-sexp-mode)
(add-hook 'org-mode-hook 'highlight-sexp-mode)
#+END_SRC

** Spaceline/Powerline

Set up spaceline style, and size. powerline-height should ideally be a percentage,
or else this value has to be changed depending on the DPI. 40 seems to be an OK
size for my monitors.
#+BEGIN_SRC emacs-lisp
(require 'spaceline-all-the-icons)
(require 'spaceline-config)
(setq powerline-default-separator 'wave)
(setq spaceline-workspace-numbers-unicode t)
(setq spaceline-window-numbers-unicode t)
(setq spaceline-highlight-face-func 'spaceline-highlight-face-evil-state)
(setq spaceline-minor-modes-p nil)
(setq spaceline-lines-p nil)
(setq powerline-height 40)
(spaceline-helm-mode)
(spaceline-info-mode)
#+END_SRC

This is my attempt to define a spaceline segment. I just want it to show the path
of the file currently open in the buffer. It unfortunately does not work.
#+BEGIN_SRC emacs-lisp
(spaceline-define-segment buffer-path
  "my segment"
  (when t
  (print buffer-file-name)))
(setq spaceline-buffer-path-p t)
#+END_SRC

Set the theme.
#+BEGIN_SRC emacs-lisp
(spaceline-spacemacs-theme)
;(spaceline-all-the-icons-theme)
#+END_SRC

** Company mode

Enable company-mode.
#+BEGIN_SRC emacs-lisp
(add-hook 'after-init-hook 'global-company-mode)
#+END_SRC

Enable Vim keybinding in company-mode window.
#+BEGIN_SRC emacs-lisp
(define-key company-active-map (kbd "C-n") 'company-select-next-or-abort)
(define-key company-active-map (kbd "C-p") 'company-select-previous-or-abort)
#+END_SRC

** Helm

Enable helm-mode
#+BEGIN_SRC emacs-lisp
(helm-mode 1)
#+END_SRC

Map =M-x= to start helm.
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "M-x") 'helm-M-x)
#+END_SRC

Define things like helm-map.
#+BEGIN_SRC emacs-lisp
(require 'helm)
(require 'helm-config)
#+END_SRC

Use =C-j= and =C-k= to navigate inside helm buffer.
#+BEGIN_SRC emacs-lisp
(define-key helm-map (kbd "C-j") 'helm-next-line)
(define-key helm-map (kbd "C-k") 'helm-previous-line)
#+END_SRC

Use tab to give function definition. I would ideally like to use tab for
auto-completion in helm, but apparently that's "not how you're supposed to use helm".
#+BEGIN_SRC emacs-lisp
(define-key helm-map (kbd "TAB") 'helm-execute-persistent-action)
#+END_SRC

More key definitions
#+BEGIN_SRC emacs-lisp
(define-key helm-map (kbd "C-b") 'helm-find-files-up-one-level)
#+END_SRC

Use =M-o= in some helm buffers to open files in a new split window. This is really
cool but, unfortunately it doesn't always work. I borrowed this from [[https://github.com/emacs-helm/helm/issues/1100#issuecomment-128939418][here]].
#+BEGIN_SRC emacs-lisp
(defun helm-buffer-switch-to-new-window (_candidate)
  "Display buffers in new windows."
  ;; Select the bottom right window
  (require 'winner)
  (select-window (car (last (winner-sorted-window-list))))
  ;; Display buffers in new windows
  (dolist (buf (helm-marked-candidates))
    (select-window (split-window-right))
    (switch-to-buffer buf))
  ;; Adjust size of windows
  (balance-windows))

(add-to-list 'helm-type-buffer-actions
             '("Display buffer(s) in new window(s) `M-o'" .
               helm-buffer-switch-new-window) 'append)

(defun helm-buffer-switch-new-window ()
  (interactive)
  (with-helm-alive-p
    (helm-quit-and-execute-action 'helm-buffer-switch-to-new-window)))

(define-key helm-buffer-map (kbd "M-o") #'helm-buffer-switch-new-window)
#+END_SRC

Set the idle delay to be even smaller
#+BEGIN_SRC emacs-lisp
(setq helm-input-idle-delay 0.001 )
#+END_SRC

Use =helm-find-files= instead of =find-files= as the default function for =C-x f=
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-x C-f") 'helm-find-files)
#+END_SRC

In a helm menu, =C-v= already maps to page-down. =C-p= should map to page-up
#+BEGIN_SRC emacs-lisp
(define-key helm-map (kbd "C-p") 'helm-previous-page)
#+END_SRC

use ripgrep for helm-ag
#+BEGIN_SRC emacs-lisp
(custom-set-variables
 '(helm-ag-base-command "rg --no-heading"))
#+END_SRC

** Hydra

[[https://github.com/abo-abo/hydra][Hydra]] makes it pretty useful to group a set of commonly used commands.
#+BEGIN_SRC emacs-lisp
(require 'hydra)
#+END_SRC

Baby hydra to quickly eval elips things
#+BEGIN_SRC emacs-lisp
(global-set-key
 (kbd "C-M-e")
 (defhydra hydra-eval (:exit t)
   "Evaluate a"
   ("r" eval-region "region" )
   ("b" eval-buffer "buffer" )))
#+END_SRC

Hydra for resizing windows. I call it from the main window manipulation hydra
below.
Also, these keybindings are sort of weird. They aren't consistent depending
on which side the window is one. There is probably a better way to do this.
#+BEGIN_SRC emacs-lisp
(defhydra hydra-window-resize ()
  "winodw resize"
  ("h" shrink-window-horizontally  "left")
  ("l" enlarge-window-horizontally "right")
  ("j" shrink-window               "down")
  ("k" enlarge-window              "up"))
#+END_SRC

Hydra for quick window splitting taken from [[http://oremacs.com/2015/02/03/one-hydra-two-hydra/][here]].
#+BEGIN_SRC emacs-lisp
(global-set-key
 (kbd "C-M-w")
 (defhydra hydra-window (:exit t)
   "window"
   ("h" evil-window-left)
   ("j" evil-window-down)
   ("k" evil-window-up)
   ("l" evil-window-right)
   ("v" (lambda ()
          (interactive)
          (split-window-right)
          (windmove-right))
        "vert")
   ("x" (lambda ()
          (interactive)
          (split-window-below)
          (windmove-down))
        "horz")
   ("s" (lambda ()
          (interactive)
          (ace-window 4)
          (add-hook 'ace-window-end-once-hook
                    'hydra-window/body))
        "swap")
   ("d" (lambda ()
          (interactive)
          (ace-window 16)
          (add-hook 'ace-window-end-once-hook
                    'hydra-window/body))
        "del")
   ("r" hydra-window-resize/body "resize-window")
   ("o" delete-other-windows "max")
   ("m" winner-undo "min")
   ("q" nil "cancel")))
#+END_SRC

Hydra for eyebrowse window manipulation
#+BEGIN_SRC emacs-lisp
(global-set-key
 (kbd "C-M-SPC")
 (defhydra hydra-perspective (:exit t)
   "perspective"
   ( "s" eyebrowse-switch-to-window-config "switch")
   ( "c" eyebrowse-create-window-config "create")
   ( "k" eyebrowse-close-window-config "kill")
   ( "r" eyebrowse-rename-window-config "rename")
   ( "n" eyebrowse-next-window-config "next")
   ( "p" eyebrowse-prev-window-config "previous")))
#+END_SRC

Hydra for projectile.
We need to "unbind" the dired keymap so that in works in dired mode. Then we
need to bind the hydra using bind-key*, because global-set-key doesn't work for
some reason.
#+BEGIN_SRC emacs-lisp
 (add-hook 'dired-mode-hook 'my-dired-mode-hook)
     (defun my-dired-mode-hook ()
       (define-key dired-mode-map (kbd "C-M-p") nil))
(bind-key*
 (kbd "C-M-p")
 (defhydra hydra-projectile (:color teal
                            :hint nil)
  "
     PROJECTILE: %(projectile-project-root)

     Find               Search/Tags          Project
------------------------------------------------------------------------------------------
  _f_: file            _a_: helm-ag             _i_: Ibuffer
  _d_: dir             _A_: ag                  _D_: Dired
  _b_: buffer          _o_: search-buffers      _s_: shell
  _r_: recent file     _g_: grep

  "
  ("a"   helm-do-ag-project-root)
  ("A"   projectile-ag)
  ("b"   helm-projectile-switch-to-buffer)
  ("d"   helm-projectile-find-dir)
  ("f"   helm-projectile-find-file)
  ("g"   ggtags-update-tags)
  ("i"   helm-projectile-ibuffer)
  ("o"   projectile-multi-occur)
  ("r"   helm-projectile-recentf)
  ("D"   projectile-dired)
  ("s"   projectile-run-shell)
  ("q"   nil "cancel" :color blue)))
#+END_SRC

A magical magit hydra
#+BEGIN_SRC emacs-lisp
(global-set-key
 (kbd "C-M-g")
 (defhydra hydra-magit (:exit t)
   "perspective"
   ( "d" magit-diff "diff")
   ( "s" magit-status "status")
   ( "l" magit-log-current "log")
   ( "p" magit-pull "pull")
   ( "b" magit-blame "blame")))
#+END_SRC

A small hydra for neotree
#+BEGIN_SRC emacs-lisp
(global-set-key
 (kbd "C-M-t")
 (defhydra hydra-neotree (:exit t)
   "perspective"
   ( "t" neotree-toggle "toggle")
   ( "p" neotree-project-dir "toggle in projectile")))
#+END_SRC

A hydra for misc utilities through helm
#+BEGIN_SRC emacs-lisp
(global-set-key
 (kbd "M-m")
 (defhydra hydra-meghanada (:hint nil :exit t)
   "
^Edit^                           ^Tast or Task^
^^^^^^-------------------------------------------------------
_f_: meghanada-compile-file      _m_: meghanada-restart
_c_: meghanada-compile-project   _t_: meghanada-run-task
_o_: meghanada-optimize-import   _j_: meghanada-run-junit-test-case
_s_: meghanada-switch-test-case  _J_: meghanada-run-junit-class
_v_: meghanada-local-variable    _R_: meghanada-run-junit-recent
_i_: meghanada-import-all        _r_: meghanada-reference
_g_: magit-status                _T_: meghanada-typeinfo
_l_: helm-ls-git-ls
_q_: exit
"
   ("f" meghanada-compile-file)
   ("m" meghanada-restart)

   ("c" meghanada-compile-project)
   ("o" meghanada-optimize-import)
   ("s" meghanada-switch-test-case)
   ("v" meghanada-local-variable)
   ("i" meghanada-import-all)

   ("g" magit-status)
   ("l" helm-ls-git-ls)

   ("t" meghanada-run-task)
   ("T" meghanada-typeinfo)
   ("j" meghanada-run-junit-test-case)
   ("J" meghanada-run-junit-class)
   ("R" meghanada-run-junit-recent)
   ("r" meghanada-reference)

   ("q" exit)
   ("z" nil "leave")))
#+END_SRC

A hydra for meghanada-mode stolen from the project's readme
#+BEGIN_SRC emacs-lisp
#+END_SRC

* Conclusion

I hope this helps some of you. I tried to refrence back the location where I found
the snippets of code that I used in my init file. If I've forgotten a refrence,
I'm very sorry.
